# IoTtoFIWARE
Starting by the FIWARE Zone Tutorial :"https://github.com/FIWAREZone/iot_curse"

This Tutorial intent to show the use of a real IoT device the ESP8266 node and a continuity of the FIWARE Tutorial "https://www.fiware.org/2015/06/10/iot-tutorial-orion-context-broker-arduino/"

The Internet of Things (IoT) is a network of physical devices which are able to connect to a network and exchange data. Each "thing" or "smart device" is a gadget with embedded electronics and software which can act as a sensor or actuator. Sensors are able to report the state of the real-world around them. Actuators are responsible for altering the state of the system, by responding to a control signal.

Each device is uniquely identifiable through its embedded computing system but is able to interoperate within the existing internet infrastructure.

FIWARE is a system for managing context information. For a smart solution based on the internet of Things, the context is provided by the array of attached IoT devices. Since each IoT device is a physical object which exists in the real world, it will eventually be represented as a unique entity within the context.

IoT devices can range from simple to complex. Here are some examples of IoT devices which will be used within this tutorial:

A Smart Door is an electronic door which can be sent commands to be locked or unlocked remotely. It can also report on its current state (OPEN, CLOSED or LOCKED),
A Bell can be sent a command to activate and ring for a short period
A Motion Sensor will activate and send a count when someone is nearby
A Smart Lamp can be switched on or off remotely. It can also report on its current state (ON or OFF). When switched on, a Motion Sensor within the device checks to see if light is needed and will dim if no-one is nearby. Furthermore the device can be report on the output state and input of each GPIO (General Purpose Input Output).
As you can see, the Bell is an example of a pure actuator, as it only reacts to the given commands. Meanwhile, the Motion Sensor is an example of a pure sensor, since it will only report on the state of the world as it sees it. The other two GPIO are able to both respond to the commands and report on state in a meaningful way.

The state information held within each device, as it will eventually be seen within the Context Broker is defined in the diagram below:
![entities image](https://github.com/iHubBridge/IoTtoFIWARE/blob/main/entities.png)

## use of ultralight Http

UltraLight 2.0 is a lightweight text based protocol for constrained devices and communications where bandwidth and device memory resources are limited. The payload for measurement requests is a list of key-value pairs separated by the pipe | character.

e.g.

> <key>|<value>|<key>|<value>|<key>|<value> etc..

For example a payload such as:

> t|15|k|abc


Contains two attributes, one named "t" with value "15" and another named "k" with value "abc" are transmitted. Values in Ultralight 2.0 are not typed (everything is treated as a string).

Ultralight 2.0 defines a payload describing measures and commands to share between devices and servers but, does not specify a single transport protocol. Instead, different transport protocol bindings (such as HTTP, MQTT and AMQP) can be used for different scenarios. For this tutorial we will be using HTTP as a transport protocol.

## Southbound Traffic (Commands)
HTTP requests generated by the form the Context Broker and passed downwards towards an IoT device (via an IoT agent **or not**) are known as southbound traffic. Southbound traffic consists of commands made to actuator devices which alter the state of the real world by their actions. For example a command to alter the state of a lamp to ON would switch on the lamp in real life. This in turn could alter the readings of other sensors nearby.

## Push Command Using HTTP POST
Setting up the southbound communication between an IoT Agent and IoT devices is known as provisioning. This ensures that the IoT Agent holds sufficient information to be able to contact each IoT device. In other words it knows where to send commands and which commands are supported. In order to send a command to a device, the IoT Agent sends a POST request to the endpoint supplied by the device. The body of the POST request holds the command.

The payload for Ultralight commands has the following format:

> <device_name>@<command>|<param|<param>

Where <device_name> is the entity id as held in the context broker, <command> is one of the supported commands and any additional required values are passed in subsequent parameters for example:

> urn:ngsi-ld:Robot:001@turn|left|30

Will tell a device _"I am known as id="urn:ngsi-ld:Robot:001" within the Context Broker. I would like the device listening on this endpoint to perform the turn command. I have supplied the parameters left and '30 (degrees) as required for the device to be able to perform the maneuver"_.

The defined Northbound response to an IoT Agent is as follows:

> urn:ngsi-ld:Robot:001@turn|Turn ok

Which is saying _"I have complied with a request from the entity known as id="urn:ngsi-ld:Robot:001" within the Context Broker. The command I have performed was a turn command. The result was Turn ok"_ .

As you can see, because the Southbound command defines the id used within the interaction, and the same data is also returned, every response can always be associated to the appropriate entity held within the Context Broker.

Push commands can only be used if the device is able to supply a separate endpoint for listening to southbound traffic, an alternative polling mechanism can be used when all interactions are initiated from the device itself, but this is beyond the scope of this tutorial.


